<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta name="renderer" content="webkit"/>
    <meta name="force-rendering" content="webkit"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <script>if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) window.location.href="https://support.dmeng.net/upgrade-your-browser.html?referrer="+encodeURIComponent(window.location.href); </script>
    
    
        <link rel="shortcut icon" href="/img/favicon.ico">
    
     
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.2.30/dist/vuetify.min.css" rel="stylesheet">
    
<link rel="stylesheet" href="/css/main.css">

    
    







    
    
          

    
    
    
    
    <title>
        
            Blind ROP | Clindy&#39;s Blog
        
    </title>
    
    
<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div id="app">
        <v-app>
            <v-content id="page">
                <v-container fluid>
                    <v-row>
                        <v-col cols="2" class="d-none d-md-block">
                            <div id="sidebar" class="float-right">
    <a href="/" rel="home">
        <v-avatar size=96>
            <img id="logo" src="/img/head.jpg">     
        </v-avatar> 
    </a>
    <v-divider></v-divider>
    <div class="mini-menu">
        <v-btn icon href="/">
            <v-icon>home</v-icon>
        </v-btn>
        <v-btn icon href="/categories/">
            <v-icon>folder</v-icon>
        </v-btn>
        <v-btn icon href="/tags/">
            <v-icon>bookmark</v-icon>
        </v-btn>
        <v-btn icon @click="SetNightMode">
            <v-icon>{{ nightMode }}</v-icon>
        </v-btn>
    </div>
    <v-list id="main-menu" class="font-weight-bold" flat>
        
            
            <v-list-item href="/classic/" link>
            <v-list-item-icon><v-icon>account_circle</v-icon></v-list-item-icon>
            <v-list-item-content>
                经典例题
            </v-list-item-content>
            </v-list-item>
        
            
            <v-list-item href="/archives/" link>
            <v-list-item-icon><v-icon>archive</v-icon></v-list-item-icon>
            <v-list-item-content>
                时间线
            </v-list-item-content>
            </v-list-item>
        
    </v-list>
    <v-divider></v-divider>
    
        <div class="post-toc">
            <a href="/2021/01/15/Classic/brop/" class="toc-header">Table of Contents</a>
            <div class="toc-content">
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Blind-ROP"><span class="toc-number">1.</span> <span class="toc-text">Blind ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">原理简述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%B0%E8%BF%99%E4%B8%80%E6%AD%A5%E4%B8%BA%E6%AD%A2%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%B0%B1%E8%83%BD%E5%A4%9F%E5%B0%86%E6%95%B4%E4%B8%AA-text%E6%AE%B5%E4%BB%8E%E5%86%85%E5%AD%98%E4%B8%AD%E9%80%9A%E8%BF%87socket%E5%86%99%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%9D%A5%E4%BA%86%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E5%8F%8D%E7%BC%96%E8%AF%91%EF%BC%8C%E6%89%BE%E5%88%B0%E5%85%B6%E4%BB%96%E6%9B%B4%E5%A4%9A%E7%9A%84gadgets%EF%BC%8C%E5%90%8C%E6%97%B6%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E8%BF%98%E5%8F%AF%E4%BB%A5dump%E9%82%A3%E4%BA%9Bsymbol-table%E4%B9%8B%E7%B1%BB%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%89%BE%E5%88%B0PLT%E4%B8%AD%E5%85%B6%E5%AE%83%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%BD%E6%95%B0%E9%A1%B9%E5%A6%82dup2%E5%92%8Cexecve%E7%AD%89%E3%80%82"><span class="toc-number">1.1.0.0.0.1.</span> <span class="toc-text">到这一步为止，攻击者就能够将整个.text段从内存中通过socket写到本地来了，然后就可以对其进行反编译，找到其他更多的gadgets，同时，攻击者还可以dump那些symbol table之类的信息，找到PLT中其它对应的函数项如dup2和execve等。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HCTF2016"><span class="toc-number">1.2.</span> <span class="toc-text">HCTF2016</span></a></li></ol></li></ol>
            </div>
        </div>
    

    <div id="footer">
        <div class="footer-social">
            
                
                <v-btn icon href="mailto:clindy.h@qq.com" target="_blank">
                    <v-icon>fas fa-envelope</v-icon>
                </v-btn>
            
                
                <v-btn icon href="https://github.com/" target="_blank">
                    <v-icon>fab fa-github</v-icon>
                </v-btn>
            
                
                <v-btn icon href="https://baidu.com" target="_blank">
                    <v-icon>fab fa-weibo</v-icon>
                </v-btn>
            
                
                <v-btn icon href="https://baidu.com" target="_blank">
                    <v-icon>fab fa-qq</v-icon>
                </v-btn>
            
        </div>
        <v-divider></v-divider>
        <div class="footer-content">
            
                <span id="busuanzi_container_site_uv" style="display: none;"> 
                    Total Visitors <span id="busuanzi_value_site_uv"></span>
                </span>
                <br>
            
            <span>Theme: <a target="_blank" rel="noopener" href="https://github.com/kb1000fx/hexo-theme-insulin">Insulin</a></span><br>
            <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span><br>
            <span>
                &copy; 2020 - 2021 
                Clindy
            </span>
        </div>
    </div>
</div>

                        </v-col>
                        <v-col cols="12" md="10">
                            <v-row>
  <v-col cols="12" md="8" align-self="end">
    <div id="site-header">
      <div id="site-title">
        <a href="/" rel="home">Clindy&#39;s Blog</a>
      </div>
      <div id="site-description">像风走了八千里，不问归期</div>
      <div id="mobile-menu" class="d-block d-md-none">
        <v-text-field label="请输入关键字" data-src="search.xml" v-model="searchHeaderValue" prepend-inner-icon="search" clearable clear-icon="clear" @keydown.enter="EnterSearch(searchHeaderValue,false)"></v-text-field>
        <div class="mobile-mini-menu">
          <v-btn icon href="/">
              <v-icon>home</v-icon>
          </v-btn>
          <v-btn icon href="/categories/">
              <v-icon>folder</v-icon>
          </v-btn>
          <v-btn icon href="/tags/">
              <v-icon>bookmark</v-icon>
          </v-btn>
          <v-btn icon @click="SetNightMode">
              <v-icon>{{ nightMode }}</v-icon>
          </v-btn>
          
            
            <v-btn icon href="/classic/">
              <v-icon>account_circle</v-icon>
            </v-btn>
          
            
            <v-btn icon href="/archives/">
              <v-icon>archive</v-icon>
            </v-btn>
          
        </div>
      </div>    
    </div>
  </v-col>  
  <v-col cols="4" align-self="end" class="d-none d-md-block">
    <v-col align-self="end">
      <v-text-field label="请输入关键字" data-src="search.xml" v-model="searchHeaderValue" prepend-icon="search" clearable clear-icon="clear" @keydown.enter="EnterSearch(searchHeaderValue,false)"></v-text-field>
    </v-col> 
  </v-col>
</v-row>

                            <v-card class="elevation-2 post-card">
    
    
        <div class="post-header">
  <a class="post-header-title font-weight-medium" href="/2021/01/15/Classic/brop/">Blind ROP</a>
  <div class="post-header-meta">   
    <span>
      <v-icon color="">event</v-icon>
      Posted on:&nbsp;2021-01-15
    </span>
    <span>
      <v-icon color="">event_available</v-icon>
      Edited on:&nbsp;2021-01-16
    </span>
    <span>
      <v-icon color="">folder</v-icon>
      In:&nbsp;<a class="category-link" href="/categories/classic/">classic</a>
    </span>
    
    <span>
      <v-icon color="">visibility</v-icon>
      Views:&nbsp;<span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
    </span>
    
  </div>
</div>

    
    
    
    
    <div class="post-content typo">
        <h1 id="Blind-ROP"><a href="#Blind-ROP" class="headerlink" title="Blind ROP"></a>Blind ROP</h1><p>这篇博客搬运了小蓝师傅的文章的部分内容（<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/196722#h3-2">文章链接</a>），旨在理清BROP的思路（基本是搬运）。之后再以HCTF2016的一道赛题brop为例，巩固一下成果。</p>
<h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><p>BROP攻击基于一篇发表在Oakland 2014的论文<strong>Hacking Blind</strong>，作者是来自Standford的Andrea Bittau，以下是相关paper和slide的链接：<a target="_blank" rel="noopener" href="http://www.scs.stanford.edu/brop/bittau-brop.pdf">paper</a>、<a target="_blank" rel="noopener" href="http://www.scs.stanford.edu/brop/bittau-brop-slides.pdf">slide</a>。</p>
<p>以及BROP的原网站地址：<a target="_blank" rel="noopener" href="http://www.scs.stanford.edu/brop/">Blind Return Oriented Programming (BROP) Website</a></p>
<p><strong>BROP攻击的目标和前提条件</strong></p>
<p>目标：通过ROP的方法远程攻击某个应用程序，劫持该应用程序的控制流。我们可以不需要知道该应用程序的源代码或者任何二进制代码，该应用程序可以被现有的一些保护机制如NX, ASLR, PIE, 以及stack canaries等保护，应用程序所在的服务器可以是32位系统或者64位系统。</p>
<p>初看这个目标感觉实现起来特别困难。其实这个攻击有两个前提条件的：</p>
<ul>
<li>必须先存在一个已知的stack overflow的漏洞，而且攻击者知道如何触发这个漏洞；</li>
<li>服务器进程在crash之后会重新复活，并且复活的进程不会被re-rand（意味着虽然有ASLR的保护，但是复活的进程和之前的进程的地址随机化是一样的）。这个需求其实是合理的，因为当前像nginx, MySQL, Apache, OpenSSH, Samba等服务器应用都是符合这种特性的。</li>
</ul>
<p><strong>BROP的攻击流程 1 – 远程dump内存</strong></p>
<p>由于我们不知道被攻击程序的内存布局，所以首先要做的事情就是通过某种方法从远程服务器dump出该程序的内存到本地，为了做到这点我们需要调用一个系统调用<code>write</code>，传入一个socket文件描述符，如下所示：</p>
<blockquote>
<p>write(int sock, void *buf, int len)</p>
</blockquote>
<p>将这条系统调用转换成4条汇编指令，如图所示：</p>
<p><a target="_blank" rel="noopener" href="https://p4.ssl.qhimg.com/t01164dfbca7ca64a95.png"><img src="brop/t01164dfbca7ca64a95.png" alt="img"></a></p>
<p>所以从ROP攻击的角度来看，我们只需要找到四个相应的gadget，然后在栈上构造好这4个gadget的内存地址，依次进行顺序调用就可以了。</p>
<p>但是问题是我们现在连内存分布都不知道，该如何在内存中找到这4个gadgets呢？特别是当系统部署了ASLR和stack canaries等保护机制，似乎这件事就更难了。</p>
<p>所以我们先将这个问题放一放，在脑袋里记着这个目标，先来做一些准备工作。</p>
<p><strong>攻破Stack Canaries防护</strong></p>
<p>canary简单来说就是在栈上的<code>return address</code>前面放一个随机生成的数（成为canary），在函数返回时进行检查，如果发现这个canary被修改了（可能是攻击者通过buffer overflow等攻击方法覆盖了），程序就会crash并报错。</p>
<p>那么如何攻破这层防护呢？一种方法是brute-force暴力破解，但这个很低效，这里作者提出了一种叫做“stack reading”的方法：</p>
<p>假设这是我们想要overflow的栈的布局：</p>
<p><a target="_blank" rel="noopener" href="https://p4.ssl.qhimg.com/t011e7f430259c2d2ec.png"><img src="brop/t011e7f430259c2d2ec.png" alt="img"></a></p>
<p>我们可以尝试任意多次来判断出overflow的长度（直到进程由于canary被破坏crash了，在这里即为<code>4096+8=4104</code>个字节），之后我们将这4096个字节填上任意值，然后一个一个字节顺序地进行尝试来还原出真实的canary，比如说，我们将第4097个字节填为<code>x</code>，如果<code>x</code>和原来的canary中的第一个字节是一样的话，那么进程不会crash，否则我们尝试下一个<code>x</code>的可能性，在这里，由于一个字节只有256种可能，所以我们只要最多尝试256次就可以找到canary的某个正确的字节，直到我们得到8个完整的canary字节，该流程如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://p3.ssl.qhimg.com/t0122a8bc04a518aefb.png"><img src="brop/t0122a8bc04a518aefb.png" alt="img"></a></p>
<p>我们同样可以用这种方法来得到保存好的<code>frame pointer</code>和<code>return address</code>。</p>
<p><strong>寻找<code>stop gadget</code></strong></p>
<p>到目前为止，我们已经得到了合适的canary来绕开stack canary的保护, 接下来的目标就是找到之前提到的4个gadgets。</p>
<p>在寻找这些特定的gadgets之前，我们需要先来介绍一种特殊的gadget类型：<code>stop gadget</code>.</p>
<p>一般情况下，如果我们把栈上的<code>return address</code>覆盖成某些我们随意选取的内存地址的话，程序有很大可能性会挂掉（比如，该<code>return address</code>指向了一段代码区域，里面会有一些对空指针的访问造成程序crash，从而使得攻击者的连接（connection）被关闭）。但是，存在另外一种情况，即该<code>return address</code>指向了一块代码区域，当程序的执行流跳到那段区域之后，程序并不会crash，而是进入了无限循环，这时程序仅仅是hang在了那里，攻击者能够一直保持连接状态。于是，我们把这种类型的gadget，称为<code>stop gadget</code>，这种gadget对于寻找其他gadgets取到了至关重要的作用。</p>
<p><strong>寻找<code>useful gadgets</code></strong></p>
<p>假设现在我们找到了某个可以造成程序block住的<code>stop gadget</code>，比如一个无限循环，或者某个blocking的系统调用（<code>sleep</code>），那么我们该如何找到其他 <code>useful gadgets</code>呢？（这里的“useful”是指有某些功能的gadget，而不是会造成crash的gadget）。</p>
<p>到目前为止我们还是只能对栈进行操作，而且只能通过覆盖<code>return address</code>来进行后续的操作。假设现在我们猜到某个<code>useful gadget</code>，比如<code>pop rdi; ret</code>, 但是由于在执行完这个gadget之后进程还会跳到栈上的下一个地址，如果该地址是一个非法地址，那么进程最后还是会crash，在这个过程中攻击者其实并不知道这个<code>useful gadget</code>被执行过了（因为在攻击者看来最后的效果都是进程crash了），因此攻击者就会认为在这个过程中并没有执行到任何的<code>useful gadget</code>，从而放弃它，这个步骤如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://p4.ssl.qhimg.com/t01317f3ecc6e86b3f8.png"><img src="brop/t01317f3ecc6e86b3f8.png" alt="img"></a></p>
<p>但是，如果我们有了<code>stop gadget</code>，那么整个过程将会很不一样. 如果我们在需要尝试的<code>return address</code>之后填上了足够多的<code>stop gadgets</code>，如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://p4.ssl.qhimg.com/t0158fb2a0edb29dfaa.png"><img src="brop/t0158fb2a0edb29dfaa.png" alt="img"></a></p>
<p>那么任何会造成进程crash的gadget最后还是会造成进程crash，而那些<code>useful gadget</code>则会进入block状态。尽管如此，还是有一种特殊情况，即那个我们需要尝试的gadget也是一个<code>stop gadget</code>，那么如上所述，它也会被我们标识为<code>useful gadget</code>。不过这并没有关系，因为之后我们还是需要检查该<code>useful gadget</code>是否是我们想要的gadget.</p>
<p><strong>最后一步：远程<code>dump</code>内存</strong></p>
<p>到目前为止，似乎准备工作都做好了，我们已经可以绕过canary防护，并且得到很多不会造成进程crash的“potential useful gadget”了，那么接下来就是该如何找到我们之前所提到的那四个gadgets呢？</p>
<p><a target="_blank" rel="noopener" href="https://p4.ssl.qhimg.com/t01ae3d96b5b86adb08.png"><img src="brop/t01ae3d96b5b86adb08.png" alt="img"></a></p>
<p>如上图所示，为了找到前两个gadgets：<code>pop %rsi; ret</code>和<code>pop %rdi; ret</code>，我们只需要找到一种所谓的<code>BROP gadget</code>就可以了，这种gadget很常见，它做的事情就是恢复那些<code>callee saved registers</code>. 而对它进行一个偏移就能够生成<code>pop %rdi</code>和<code>pop %rsi</code>这两个gadgets.</p>
<p>不幸的是<code>pop %rdx; ret</code>这个gadget并不容易找到，它很少出现在代码里, 所以作者提出一种方法，相比于寻找<code>pop %rdx</code>指令，他认为可以利用<code>strcmp</code>这个函数调用，该函数调用会把字符串的长度赋值给<code>%rdx</code>，从而达到相同的效果。另外<code>strcmp</code>和<code>write</code>调用都可以在程序的Procedure Linking Table (PLT)里面找到.</p>
<p>所以接下来的任务就是：</p>
<ul>
<li>找到所谓的<code>BROP Gadget</code>；</li>
<li>找到对应的PLT项。</li>
</ul>
<p><strong>寻找<code>BROP Gadget</code></strong></p>
<p>事实上<code>BROP gadgets</code>特别特殊，因为它需要顺序地从栈上<code>pop</code> 6个值然后执行<code>ret</code>。所以如果我们利用之前提到的<code>stop gadget</code>的方法就可以很容易找到这种特殊的gadget了，我们只需要在<code>stop gadget</code>之前填上6个会造成crash的地址:</p>
<p><a target="_blank" rel="noopener" href="https://p2.ssl.qhimg.com/t012e7a87015815966f.png"><img src="brop/t012e7a87015815966f.png" alt="img"></a></p>
<p>如果任何<code>useful gadget</code>满足这个条件且不会crash的话，那么它基本上就是<code>BROP gadgets</code>了。</p>
<p><strong>寻找PLT项</strong></p>
<p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Dynamic_linking">PLT</a>是一个跳转表，它的位置一般在可执行程序开始的地方，该机制主要被用来给应用程序调用外部函数（比如libc等），具体的细节可以看相关的Wiki。它有一个非常独特的signature：每一个项都是16个字节对齐，其中第0个字节开始的地址指向该项对应函数的fast path，而第6个字节开始的地址指向了该项对应函数的slow path：</p>
<p><a target="_blank" rel="noopener" href="https://p5.ssl.qhimg.com/t01cc2b388606f7aec2.png"><img src="brop/t01cc2b388606f7aec2.png" alt="img"></a></p>
<p>另外，大部分的PLT项都不会因为传进来的参数的原因crash，因为它们很多都是系统调用，都会对参数进行检查，如果有错误会返回EFAULT而已，并不会造成进程crash。所以攻击者可以通过下面这个方法找到PLT：如果攻击者发现好多条连续的16个字节对齐的地址都不会造成进程crash，而且这些地址加6得到的地址也不会造成进程crash，那么很有可能这就是某个PLT对应的项了。</p>
<p>那么当我们得到某个PLT项，我们该如何判断它是否是<code>strcmp</code>或者<code>write</code>呢？</p>
<p>对于<code>strcmp</code>来说, 作者提出的方法是对其传入不同的参数组合，通过该方法调用返回的结果来进行判断。由于<code>BROP gadget</code>的存在，我们可以很方便地控制前两个参数，<code>strcmp</code>会发生如下的可能性：</p>
<table>
<thead>
<tr>
<th align="center">arg1</th>
<th align="center">arg2</th>
<th align="center">result</th>
</tr>
</thead>
<tbody><tr>
<td align="center">readable</td>
<td align="center">0x0</td>
<td align="center">crash</td>
</tr>
<tr>
<td align="center">0x0</td>
<td align="center">readable</td>
<td align="center">crash</td>
</tr>
<tr>
<td align="center">0x0</td>
<td align="center">0x0</td>
<td align="center">crash</td>
</tr>
<tr>
<td align="center">readable</td>
<td align="center">readable</td>
<td align="center">no-crash</td>
</tr>
</tbody></table>
<p>根据这个signature, 我们能够在很大可能性上找到<code>strcmp</code>对应的PLT项。</p>
<p>而对于<code>write</code>调用，虽然它没有这种类似的signature，但是我们可以通过检查所有的PLT项，然后触发其向某个socket写数据来检查<code>write</code>是否被调用了，如果<code>write</code>被调用了，那么我们就可以在本地看到传过来的内容了。</p>
<p>最后一步就是如何确定传给<code>write</code>的socket文件描述符是多少了。这里有两种办法：1. 同时调用好几次write，把它们串起来，然后传入不同的文件描述符数；2. 同时打开多个连接，然后使用一个相对较大的文件描述符数字，增加匹配的可能性。</p>
<h6 id="到这一步为止，攻击者就能够将整个-text段从内存中通过socket写到本地来了，然后就可以对其进行反编译，找到其他更多的gadgets，同时，攻击者还可以dump那些symbol-table之类的信息，找到PLT中其它对应的函数项如dup2和execve等。"><a href="#到这一步为止，攻击者就能够将整个-text段从内存中通过socket写到本地来了，然后就可以对其进行反编译，找到其他更多的gadgets，同时，攻击者还可以dump那些symbol-table之类的信息，找到PLT中其它对应的函数项如dup2和execve等。" class="headerlink" title="到这一步为止，攻击者就能够将整个.text段从内存中通过socket写到本地来了，然后就可以对其进行反编译，找到其他更多的gadgets，同时，攻击者还可以dump那些symbol table之类的信息，找到PLT中其它对应的函数项如dup2和execve等。"></a>到这一步为止，攻击者就能够将整个<code>.text</code>段从内存中通过socket写到本地来了，然后就可以对其进行反编译，找到其他更多的gadgets，同时，攻击者还可以dump那些symbol table之类的信息，找到PLT中其它对应的函数项如<code>dup2</code>和<code>execve</code>等。</h6><p><strong>BROP的攻击流程 2 – 实施攻击</strong></p>
<p>到目前为止，最具挑战性的部分已经被解决了，我们已经可以得到被攻击进程的整个内存空间了，接下来就是按部就班了（从论文中翻译）：</p>
<ul>
<li>将socket重定向到标准输入/输出（standard input/output）。攻击者可以使用<code>dup2</code>或<code>close</code>，跟上<code>dup</code>或者<code>fcntl(F_DUPFD)</code>。这些一般都能在PLT里面找到。</li>
<li>在内存中找到<code>/bin/sh</code>。其中一个有效的方法是从symbol table里面找到一个可写区域（writable memory region），比如<code>environ</code>，然后通过socket将<code>/bin/sh</code>从攻击者这里读过去。</li>
<li><code>execve</code> shell. 如果<code>execve</code>不在PLT上, 那么攻击者就需要通过更多次的尝试来找到一个<code>pop rax; ret</code>和<code>syscall</code>的gadget.</li>
</ul>
<p>归纳起来，BROP攻击的整个步骤是这样的：</p>
<ul>
<li>通过一个已知的stack overflow的漏洞，并通过stack reading的方式绕过stack canary的防护，试出某个可用的return address；</li>
<li>寻找<code>stop gadget</code>：一般情况下这会是一个在PLT中的blocking系统调用的地址（sleep等），在这一步中，攻击者也可以找到PLT的合法项；</li>
<li>寻找<code>BROP gadget</code>：这一步之后攻击者就能够控制<code>write</code>系统调用的前两个参数了；</li>
<li>通过signature的方式寻找到PLT上的<code>strcmp</code>项，然后通过控制字符串的长度来给<code>%rdx</code>赋值，这一步之后攻击者就能够控制<code>write</code>系统调用的第三个参数了；</li>
<li>寻找PLT中的<code>write</code>项：这一步之后攻击者就能够将整个内存从远端dump到本地，用于寻找更多的gadgets；</li>
<li>有了以上的信息之后，就可以创建一个shellcode来实施攻击了。</li>
</ul>
<h2 id="HCTF2016"><a href="#HCTF2016" class="headerlink" title="HCTF2016"></a>HCTF2016</h2><p>出题人在 github 上开源了代码，<a target="_blank" rel="noopener" href="https://github.com/zh-explorer/hctf2016-brop">出题人失踪了</a>。如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;WelCome my friend,Do you know password?&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!check()) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Do not dump my memory&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;No password, no game&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(buf, <span class="string">&quot;aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//$ gcc -z noexecstack -fno-stack-protector -no-pie brop.c</span></span><br></pre></td></tr></table></figure>
<p>因为是盲打，所以默认自己目前无法看到程序的源码，而是在运行程序时利用漏洞，dump出这个程序的副本。</p>

    </div>
    <!--文末结束语-->
    
        <div style="text-align:center;color: #ccc;font-size:14px;"> --- 本文结束 <i class="fas fa-heart"></i> The End --- </div>
    
    <!--页脚广告-->
    
    <v-divider></v-divider>
    
    <div class="post-nav">             
        
            <div class="post-nav-button float-left">
                <v-icon>chevron_left</v-icon>
                <a class="font-weight-bold text-left" href="/2021/01/15/brop/">
                    HCTF2016 brop
                </a>
            </div>
              
          
            <div class="post-nav-button float-right">
                <a class="font-weight-bold text-right" href="/2021/01/14/CVE/CVE-2018-1160/">      
                    CVE-2018-1160
                </a>
                <v-icon>chevron_right</v-icon>
            </div>
        
    </div>
</v-card>



        
                            <div id="mobile-footer" class="d-block d-md-none">
                                <v-divider></v-divider>
                                <div id="mobile-footer-content">
                                    <span>Theme: <a target="_blank" rel="noopener" href="https://github.com/kb1000fx/hexo-theme-insulin">Insulin</a> &nbsp; Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span><br>
                                    <span> &copy; 2020 - 2021 Clindy</span>
                                </div>
                            </div>                   
                        </v-col>                                            
                    </v-row>
                </v-container>
            </v-content>
        </v-app>
    </div>
    
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify@2.2.30"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-base64@3.5.2/base64.min.js"></script>

<script src="/js/main.js"></script>




    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://cdn.jsdelivr.net/npm/mermaid@8.4.8/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({
        startOnLoad: true,
        theme: "default"
    });</script>





</body>
</html>